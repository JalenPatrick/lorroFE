{"version":3,"file":"static/webpack/static/development/pages/record.js.e2a95bdb6cd3054da3f1.hot-update.js","sources":["webpack:///./node_modules/audio-resampler/lib/resampler.js","webpack:///./node_modules/wav-encoder/lib/encoder-worker.js","webpack:///./node_modules/wav-encoder/lib/encoder.js","webpack:///./node_modules/wav-encoder/lib/index.js","webpack:///./node_modules/wav-encoder/node_modules/inline-worker/lib/index.js","webpack:///./node_modules/wav-encoder/node_modules/inline-worker/lib/inline-worker.js","webpack:///./node_modules/webaudioloader/lib/webaudioloader.js","webpack:///./node_modules/webaudioloader/node_modules/lru-cache/lib/lru-cache.js","webpack:///./pages/record.js"],"sourcesContent":["\"use strict\";\n\nvar WebAudioLoader = require('webaudioloader');\nvar WavEncoder = require(\"wav-encoder\");\n\n// WebAudio Shim.\nwindow.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n\nvar audioContext = new AudioContext();\n\nvar wal = new WebAudioLoader({\n    context: audioContext,\n    cache: false\n});\n\nfunction resampler(input, targetSampleRate, oncomplete) {\n\n    if (!input && !targetSampleRate) {\n        return returnError('Error: First argument should be either a File, URL or AudioBuffer');\n    }\n\n    var inputType = Object.prototype.toString.call(input);\n    if (inputType !== '[object String]' &&\n        inputType !== '[object File]' &&\n        inputType !== '[object AudioBuffer]' &&\n        inputType !== '[object Object]') {\n        return returnError('Error: First argument should be either a File, URL or AudioBuffer');\n    }\n\n    if (typeof targetSampleRate !== 'number' ||\n        targetSampleRate > 192000 || targetSampleRate < 3000) {\n        return returnError('Error: Second argument should be a numeric sample rate between 3000 and 192000');\n    }\n\n    if (inputType === '[object String]' || inputType === '[object File]') {\n        console.log('Loading/decoding input', input);\n        wal.load(input, {\n            onload: function(err, audioBuffer) {\n                if (err) {\n                    return returnError(err);\n                }\n                resampleAudioBuffer(audioBuffer);\n            }\n        });\n    } else if (inputType === '[object AudioBuffer]') {\n        resampleAudioBuffer(input);\n    } else if (inputType === '[object Object]' && input.leftBuffer && input.sampleRate) {\n        var numCh_ = input.rightBuffer ? 2 : 1;\n        var audioBuffer_ = audioContext.createBuffer(numCh_, input.leftBuffer.length, input.sampleRate);\n        resampleAudioBuffer(audioBuffer_);\n    } else {\n        return returnError('Error: Unknown input type');\n    }\n\n    function returnError(errMsg) {\n        console.error(errMsg);\n        if (typeof oncomplete === 'function') {\n            oncomplete(new Error(errMsg));\n        }\n        return;\n    }\n\n    function resampleAudioBuffer(audioBuffer) {\n\n\n        var numCh_ = audioBuffer.numberOfChannels;\n        var numFrames_ = audioBuffer.length * targetSampleRate / audioBuffer.sampleRate;\n\n        var offlineContext_ = new OfflineAudioContext(numCh_, numFrames_, targetSampleRate);\n        var bufferSource_ = offlineContext_.createBufferSource();\n        bufferSource_.buffer = audioBuffer;\n\n        offlineContext_.oncomplete = function(event) {\n            var resampeledBuffer = event.renderedBuffer;\n            console.log('Done Rendering');\n            if (typeof oncomplete === 'function') {\n                oncomplete({\n                    getAudioBuffer: function() {\n                        return resampeledBuffer;\n                    },\n                    getFile: function(fileCallback) {\n                        var audioData = {\n                            sampleRate: resampeledBuffer.sampleRate,\n                            channelData: []\n                        };\n                        for (var i = 0; i < resampeledBuffer.numberOfChannels; i++) {\n                            audioData.channelData[i] = resampeledBuffer.getChannelData(i);\n                        }\n                        WavEncoder.encode(audioData).then(function(buffer) {\n                            var blob = new Blob([buffer], {\n                                type: \"audio/wav\"\n                            });\n                            fileCallback(URL.createObjectURL(blob));\n                        });\n                    }\n                });\n            }\n        };\n\n        console.log('Starting Offline Rendering');\n        bufferSource_.connect(offlineContext_.destination);\n        bufferSource_.start(0);\n        offlineContext_.startRendering();\n    }\n}\n\n\nmodule.exports = resampler;\n","\"use strict\";\n/* jshint esnext: false */\n\n/**\n  CAUTION!!!!\n  This file is used in WebWorker.\n  So, must write with ES5, not use ES6.\n  You need attention not to be traspiled by babel.\n*/\n\nvar self = {};\n\nfunction encoder() {\n  self.onmessage = function (e) {\n    switch (e.data.type) {\n      case \"encode\":\n        self.encode(e.data.audioData, e.data.format).then(function (buffer) {\n          var data = {\n            type: \"encoded\",\n            callbackId: e.data.callbackId,\n            buffer: buffer\n          };\n          self.postMessage(data, [buffer]);\n        }, function (err) {\n          var data = {\n            type: \"error\",\n            callbackId: e.data.callbackId,\n            message: err.message\n          };\n          self.postMessage(data);\n        });\n        break;\n    }\n  };\n\n  self.encode = function (audioData, format) {\n    format.floatingPoint = !!format.floatingPoint;\n    format.bitDepth = format.bitDepth | 0 || 16;\n\n    return new Promise(function (resolve) {\n      var numberOfChannels = audioData.numberOfChannels;\n      var sampleRate = audioData.sampleRate;\n      var bytes = format.bitDepth >> 3;\n      var length = audioData.length * numberOfChannels * bytes;\n      var writer = new BufferWriter(44 + length);\n\n      writer.writeString(\"RIFF\"); // RIFF header\n      writer.writeUint32(writer.length - 8); // file length\n      writer.writeString(\"WAVE\"); // RIFF Type\n\n      writer.writeString(\"fmt \"); // format chunk identifier\n      writer.writeUint32(16); // format chunk length\n      writer.writeUint16(format.floatingPoint ? 3 : 1); // format (PCM)\n      writer.writeUint16(numberOfChannels); // number of channels\n      writer.writeUint32(sampleRate); // sample rate\n      writer.writeUint32(sampleRate * numberOfChannels * bytes); // byte rate\n      writer.writeUint16(numberOfChannels * bytes); // block size\n      writer.writeUint16(format.bitDepth); // bits per sample\n\n      writer.writeString(\"data\"); // data chunk identifier\n      writer.writeUint32(length); // data chunk length\n\n      var channelData = audioData.buffers.map(function (buffer) {\n        return new Float32Array(buffer);\n      });\n\n      writer.writePCM(channelData, format);\n\n      resolve(writer.toArrayBuffer());\n    });\n  };\n\n  function BufferWriter(length) {\n    this.buffer = new ArrayBuffer(length);\n    this.view = new DataView(this.buffer);\n    this.length = length;\n    this.pos = 0;\n  }\n\n  BufferWriter.prototype.writeUint8 = function (data) {\n    this.view.setUint8(this.pos, data);\n    this.pos += 1;\n  };\n\n  BufferWriter.prototype.writeUint16 = function (data) {\n    this.view.setUint16(this.pos, data, true);\n    this.pos += 2;\n  };\n\n  BufferWriter.prototype.writeUint32 = function (data) {\n    this.view.setUint32(this.pos, data, true);\n    this.pos += 4;\n  };\n\n  BufferWriter.prototype.writeString = function (data) {\n    for (var i = 0; i < data.length; i++) {\n      this.writeUint8(data.charCodeAt(i));\n    }\n  };\n\n  BufferWriter.prototype.writePCM8 = function (x) {\n    x = Math.max(-128, Math.min(x * 128, 127)) | 0;\n    this.view.setInt8(this.pos, x);\n    this.pos += 1;\n  };\n\n  BufferWriter.prototype.writePCM16 = function (x) {\n    x = Math.max(-32768, Math.min(x * 32768, 32767)) | 0;\n    this.view.setInt16(this.pos, x, true);\n    this.pos += 2;\n  };\n\n  BufferWriter.prototype.writePCM24 = function (x) {\n    x = Math.max(-8388608, Math.min(x * 8388608, 8388607)) | 0;\n    this.view.setUint8(this.pos + 0, x >> 0 & 255);\n    this.view.setUint8(this.pos + 1, x >> 8 & 255);\n    this.view.setUint8(this.pos + 2, x >> 16 & 255);\n    this.pos += 3;\n  };\n\n  BufferWriter.prototype.writePCM32 = function (x) {\n    x = Math.max(-2147483648, Math.min(x * 2147483648, 2147483647)) | 0;\n    this.view.setInt32(this.pos, x, true);\n    this.pos += 4;\n  };\n\n  BufferWriter.prototype.writePCM32F = function (x) {\n    this.view.setFloat32(this.pos, x, true);\n    this.pos += 4;\n  };\n\n  BufferWriter.prototype.writePCM64F = function (x) {\n    this.view.setFloat64(this.pos, x, true);\n    this.pos += 8;\n  };\n\n  BufferWriter.prototype.writePCM = function (channelData, format) {\n    var length = channelData[0].length;\n    var numberOfChannels = channelData.length;\n    var method = \"writePCM\" + format.bitDepth;\n\n    if (format.floatingPoint) {\n      method += \"F\";\n    }\n\n    if (!this[method]) {\n      throw new Error(\"not suppoerted bit depth \" + format.bitDepth);\n    }\n\n    for (var i = 0; i < length; i++) {\n      for (var ch = 0; ch < numberOfChannels; ch++) {\n        this[method](channelData[ch][i]);\n      }\n    }\n  };\n\n  BufferWriter.prototype.toArrayBuffer = function () {\n    return this.buffer;\n  };\n\n  self.BufferWriter = BufferWriter;\n}\n\nencoder.self = encoder.util = self;\n\nmodule.exports = encoder;","\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\n\"use stirct\";\n\nvar InlineWorker = _interopRequire(require(\"inline-worker\"));\n\nvar encoder = _interopRequire(require(\"./encoder-worker\"));\n\nvar Encoder = (function () {\n  function Encoder() {\n    var _this = this;\n\n    var format = arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, Encoder);\n\n    this.format = {\n      floatingPoint: !!format.floatingPoint,\n      bitDepth: format.bitDepth | 0 || 16 };\n    this._worker = new InlineWorker(encoder, encoder.self);\n    this._worker.onmessage = function (e) {\n      var callback = _this._callbacks[e.data.callbackId];\n\n      if (callback) {\n        if (e.data.type === \"encoded\") {\n          callback.resolve(e.data.buffer);\n        } else {\n          callback.reject(new Error(e.data.message));\n        }\n      }\n\n      _this._callbacks[e.data.callbackId] = null;\n    };\n    this._callbacks = [];\n  }\n\n  _createClass(Encoder, {\n    canProcess: {\n      value: function canProcess(format) {\n        return Encoder.canProcess(format);\n      }\n    },\n    encode: {\n      value: function encode(audioData, format) {\n        var _this = this;\n\n        if (format == null || typeof format !== \"object\") {\n          format = this.format;\n        }\n        return new Promise(function (resolve, reject) {\n          var callbackId = _this._callbacks.length;\n\n          _this._callbacks.push({ resolve: resolve, reject: reject });\n\n          var numberOfChannels = audioData.channelData.length;\n          var length = audioData.channelData[0].length;\n          var sampleRate = audioData.sampleRate;\n          var buffers = audioData.channelData.map(function (data) {\n            return data.buffer;\n          });\n\n          audioData = { numberOfChannels: numberOfChannels, length: length, sampleRate: sampleRate, buffers: buffers };\n\n          _this._worker.postMessage({\n            type: \"encode\", audioData: audioData, format: format, callbackId: callbackId\n          }, audioData.buffers);\n        });\n      }\n    }\n  }, {\n    canProcess: {\n      value: function canProcess(format) {\n        if (format && (format === \"wav\" || format.type === \"wav\")) {\n          return \"maybe\";\n        }\n        return \"\";\n      }\n    },\n    encode: {\n      value: function encode(audioData, format) {\n        return new Encoder(format).encode(audioData);\n      }\n    }\n  });\n\n  return Encoder;\n})();\n\nmodule.exports = Encoder;","\"use strict\";\n\nvar _interopRequire = function (obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; };\n\nvar Encoder = _interopRequire(require(\"./encoder\"));\n\nmodule.exports = Encoder;","\"use strict\";\n\nmodule.exports = require(\"./inline-worker\");","\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar WORKER_ENABLED = !!(global === global.window && global.URL && global.Blob && global.Worker);\n\nvar InlineWorker = (function () {\n  function InlineWorker(func, self) {\n    var _this = this;\n\n    _classCallCheck(this, InlineWorker);\n\n    if (WORKER_ENABLED) {\n      var functionBody = func.toString().trim().match(/^function\\s*\\w*\\s*\\([\\w\\s,]*\\)\\s*{([\\w\\W]*?)}$/)[1];\n      var url = global.URL.createObjectURL(new global.Blob([functionBody], { type: \"text/javascript\" }));\n\n      return new global.Worker(url);\n    }\n\n    this.self = self;\n    this.self.postMessage = function (data) {\n      setTimeout(function () {\n        _this.onmessage({ data: data });\n      }, 0);\n    };\n\n    setTimeout(function () {\n      func.call(self);\n    }, 0);\n  }\n\n  _createClass(InlineWorker, {\n    postMessage: {\n      value: function postMessage(data) {\n        var _this = this;\n\n        setTimeout(function () {\n          _this.self.onmessage({ data: data });\n        }, 0);\n      }\n    }\n  });\n\n  return InlineWorker;\n})();\n\nmodule.exports = InlineWorker;","\"use strict\";\n\n/*\n\tconstructor\n\tvar wal = new WebAudioLoader({cache : false, maxCacheSize : 1000, onload: function(){}, onprogress: function(){}, context : audioContext })\n */\nfunction WebAudioLoader (options){\n\n\tif ( !( this instanceof WebAudioLoader ) ) {\n\t\tthrow new TypeError( \"WebAudioLoader constructor cannot be called as a function.\" );\n\t}\n\n\twindow.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n\t// Singleton using a global reference.\n\tif (window.webAudioLoader){\n\t\treturn window.webAudioLoader;\n\t}\n\n\t\t// setup cache object\n\tthis._cachedAudio = null;\n\n\t// Define default local properties\n\tthis.cache = true;\n\tthis.onload = null;\n\tthis.onprogress = null;\n\tObject.defineProperty(this,'maxCacheSize', {\n\t\tenumerable: true,\n\t\tconfigurable: false,\n\t\tset : function (maxSize){\n\t\t\tif (this._cachedAudio){\n\t\t\t\tthis._cachedAudio.max = maxSize;\n\t\t\t}\n\t\t},\n\t\tget : function (){\n\t\t\treturn this._cachedAudio.max;\n\t\t}\n\t});\n\n\t// Options parsing.\n\toptions = options || {};\n\tfor (var opt in options){\n\t\tif (this.hasOwnProperty(opt) && options[opt] !== undefined){\n\t\t\tthis[opt] = options[opt];\n\t\t}\n\t}\n\tthis.context = options.audioContext || new AudioContext();\n\n\t// Setup Cache\n\tvar cacheOptions = {\n\t\tmax: options.maxCacheSize || 1000,\n\t\tlength: function(audioBuffer){\n\t\t\treturn (audioBuffer.length*audioBuffer.numberOfChannels*4)/1000;\n\t\t}\n\t};\n\tthis._cachedAudio = require('lru-cache')(cacheOptions);\n\n\n\t// Resgiter as global\n\twindow.webAudioLoader = this;\n\n\t// Helper functions\n\tthis._loadURLOrFile = function (URL, onprogress, onload){\n\t\tvar urlType = Object.prototype.toString.call( URL );\n\t\tvar request = null;\n\t\tif (urlType === '[object String]'){\n\t\t\trequest = new XMLHttpRequest();\n\t\t\trequest.open('GET', URL, true);\n\t\t\trequest.responseType = 'arraybuffer';\n\t\t}\n\t\telse if (urlType === '[object File]' || urlType === '[object Blob]' ){\n\t\t\trequest = new FileReader();\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\n\t\trequest.onload = function () {\n\t\t\tif (urlType === '[object String]' && request.status === 200){\n\t\t\t\tif (typeof onload === 'function'){\n\t\t\t\t\tonload(null, request.response);\n\t\t\t\t}\n\t\t\t}else if (urlType === '[object File]' || urlType === '[object Blob]'){\n\t\t\t\tif (typeof onload === 'function'){\n\t\t\t\t\t\tonload(null, request.result);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif (typeof onload === 'function'){\n\t\t\t\t\tonload(new Error(\"Loading Error\"), null);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\trequest.onerror = function(){\n\t\t\tif (typeof onload === 'function'){\n\t\t\t\tonload(new Error(\"Loading Error\"), null);\n\t\t\t}\n\t\t};\n\t\trequest.onprogress = function(event){\n\t\t\tif (typeof onprogress === 'function'){\n\t\t\t\tonprogress(event);\n\t\t\t}\n\n\t\t\tif (typeof this.onprogress === 'function'){\n\t\t\t\tthis.onprogress(event);\n\t\t\t}\n\t\t}.bind(this);\n\n\t\tif (urlType === '[object String]'){\n\t\t\trequest.send();\n\t\t}else if (urlType === '[object File]' || urlType === '[object Blob]' ){\n\t\t\trequest.readAsArrayBuffer( URL );\n\t\t}\n\n\t};\n}\n/*\n\tload method.\n\twal.load('http://www.example.com/audio.mp3');\n\twal.load([object File]);\n\twal.load('http://www.example.com/audio.mp3', {decode: false,cache : false , onload: function(){}, onprogress: function(){}});\n */\nWebAudioLoader.prototype.load = function (source, options){\n\n\tvar decode =  true;\n\tvar thisLoadCache = true;\n\n\tif (!options) {\n\t\toptions = {};\n\t}\n\tvar thisLoadOnload = options.onload || null;\n\tvar thisLoadOnprogress = options.onprogress || null;\n\t// var startPoint = options.startPoint || 0;\n\t// var endPoint = options.endPoint || 0;\n\n\n\tif (options.cache !== null && options.cache !== undefined){\n\t\tthisLoadCache = options.cache;\n\t}else{\n\t\tthisLoadCache = this.cache;\n\t}\n\n\tif (options.decode !== null && options.decode !== undefined){\n\t\tdecode = options.decode;\n\t}\n\n\tvar onLoadProxy = function (err,audioBuffer){\n\t\tif(typeof thisLoadOnload === 'function'){\n\t\t\tthisLoadOnload(err,audioBuffer);\n\t\t}\n\t\tif (typeof this.onload === 'function'){\n\t\t\tthis.onload(err,audioBuffer);\n\t\t}\n\t}.bind(this);\n\n\tif (this.cache && thisLoadCache){\n\t\tvar testCache = this._cachedAudio.get(source);\n\t\tif (testCache){\n\t\t\tonLoadProxy(null, testCache);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tthis._loadURLOrFile(source, thisLoadOnprogress, function (err, arrayBuffer){\n\t\tif(err || !decode){\n\t\t\tonLoadProxy(err,arrayBuffer);\n\t\t}else{\n\t\t\tthis.context.decodeAudioData(arrayBuffer, function(audioBuffer){\n\t\t\t\tif (thisLoadCache){\n\t\t\t\t\tthis._cachedAudio.set(source,audioBuffer);\n\t\t\t\t}\n\t\t\t\tonLoadProxy(err,audioBuffer);\n\t\t\t}.bind(this), function(){\n\t\t\t\tonLoadProxy(new Error(\"Decoding Error\"),null);\n\t\t\t}.bind(this));\n\t\t}\n\t}.bind(this));\n};\n\n/*\n\tflushCache method\n\tResets and empties the cache.\n */\nWebAudioLoader.prototype.flushCache = function (){\n\tthis._cachedAudio.reset();\n};\n\nmodule.exports = WebAudioLoader;\n",";(function () { // closure for web browsers\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nvar didTypeWarning = false\nfunction typeCheckKey(key) {\n  if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {\n    didTypeWarning = true\n    console.error(new TypeError(\"LRU: key must be a string or number. Almost certainly a bug! \" + typeof key).stack)\n  }\n}\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache))\n    return new LRUCache(options)\n\n  if (typeof options === 'number')\n    options = { max: options }\n\n  if (!options)\n    options = {}\n\n  this._max = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!this._max || !(typeof this._max === \"number\") || this._max <= 0 )\n    this._max = Infinity\n\n  this._lengthCalculator = options.length || naiveLength\n  if (typeof this._lengthCalculator !== \"function\")\n    this._lengthCalculator = naiveLength\n\n  this._allowStale = options.stale || false\n  this._maxAge = options.maxAge || null\n  this._dispose = options.dispose\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, \"max\",\n  { set : function (mL) {\n      if (!mL || !(typeof mL === \"number\") || mL <= 0 ) mL = Infinity\n      this._max = mL\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._max }\n  , enumerable : true\n  })\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, \"lengthCalculator\",\n  { set : function (lC) {\n      if (typeof lC !== \"function\") {\n        this._lengthCalculator = naiveLength\n        this._length = this._itemCount\n        for (var key in this._cache) {\n          this._cache[key].length = 1\n        }\n      } else {\n        this._lengthCalculator = lC\n        this._length = 0\n        for (var key in this._cache) {\n          this._cache[key].length = this._lengthCalculator(this._cache[key].value)\n          this._length += this._cache[key].length\n        }\n      }\n\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._lengthCalculator }\n  , enumerable : true\n  })\n\nObject.defineProperty(LRUCache.prototype, \"length\",\n  { get : function () { return this._length }\n  , enumerable : true\n  })\n\n\nObject.defineProperty(LRUCache.prototype, \"itemCount\",\n  { get : function () { return this._itemCount }\n  , enumerable : true\n  })\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  var i = 0\n  var itemCount = this._itemCount\n\n  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {\n    i++\n    var hit = this._lruList[k]\n    if (isStale(this, hit)) {\n      del(this, hit)\n      if (!this._allowStale) hit = undefined\n    }\n    if (hit) {\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  var keys = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    keys[i++] = hit.key\n  }\n  return keys\n}\n\nLRUCache.prototype.values = function () {\n  var values = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    values[i++] = hit.value\n  }\n  return values\n}\n\nLRUCache.prototype.reset = function () {\n  if (this._dispose && this._cache) {\n    for (var k in this._cache) {\n      this._dispose(k, this._cache[k].value)\n    }\n  }\n\n  this._cache = Object.create(null) // hash of items by key\n  this._lruList = Object.create(null) // list of items in order of use recency\n  this._mru = 0 // most recently used\n  this._lru = 0 // least recently used\n  this._length = 0 // number of items in the list\n  this._itemCount = 0\n}\n\nLRUCache.prototype.dump = function () {\n  var arr = []\n  var i = 0\n\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    if (!isStale(this, hit)) {\n      //Do not store staled hits\n      ++i\n      arr.push({\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      });\n    }\n  }\n  //arr has the most read first\n  return arr\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this._lruList\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this._maxAge\n  typeCheckKey(key)\n\n  var now = maxAge ? Date.now() : 0\n  var len = this._lengthCalculator(value)\n\n  if (hOP(this._cache, key)) {\n    if (len > this._max) {\n      del(this, this._cache[key])\n      return false\n    }\n    // dispose of the old one before overwriting\n    if (this._dispose)\n      this._dispose(key, this._cache[key].value)\n\n    this._cache[key].now = now\n    this._cache[key].maxAge = maxAge\n    this._cache[key].value = value\n    this._length += (len - this._cache[key].length)\n    this._cache[key].length = len\n    this.get(key)\n\n    if (this._length > this._max)\n      trim(this)\n\n    return true\n  }\n\n  var hit = new Entry(key, value, this._mru++, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this._max) {\n    if (this._dispose) this._dispose(key, value)\n    return false\n  }\n\n  this._length += hit.length\n  this._lruList[hit.lu] = this._cache[key] = hit\n  this._itemCount ++\n\n  if (this._length > this._max)\n    trim(this)\n\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  typeCheckKey(key)\n  if (!hOP(this._cache, key)) return false\n  var hit = this._cache[key]\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  typeCheckKey(key)\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  typeCheckKey(key)\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var hit = this._lruList[this._lru]\n  del(this, hit)\n  return hit || null\n}\n\nLRUCache.prototype.del = function (key) {\n  typeCheckKey(key)\n  del(this, this._cache[key])\n}\n\nLRUCache.prototype.load = function (arr) {\n  //reset the cache\n  this.reset();\n\n  var now = Date.now()\n  //A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l-- ) {\n    var hit = arr[l]\n    typeCheckKey(hit.k)\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      //the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      //dont add already expired items\n      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)\n    }\n  }\n}\n\nfunction get (self, key, doUse) {\n  typeCheckKey(key)\n  var hit = self._cache[key]\n  if (hit) {\n    if (isStale(self, hit)) {\n      del(self, hit)\n      if (!self._allowStale) hit = undefined\n    } else {\n      if (doUse) use(self, hit)\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale(self, hit) {\n  if (!hit || (!hit.maxAge && !self._maxAge)) return false\n  var stale = false;\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self._maxAge && (diff > self._maxAge)\n  }\n  return stale;\n}\n\nfunction use (self, hit) {\n  shiftLU(self, hit)\n  hit.lu = self._mru ++\n  self._lruList[hit.lu] = hit\n}\n\nfunction trim (self) {\n  while (self._lru < self._mru && self._length > self._max)\n    del(self, self._lruList[self._lru])\n}\n\nfunction shiftLU (self, hit) {\n  delete self._lruList[ hit.lu ]\n  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++\n}\n\nfunction del (self, hit) {\n  if (hit) {\n    if (self._dispose) self._dispose(hit.key, hit.value)\n    self._length -= hit.length\n    self._itemCount --\n    delete self._cache[ hit.key ]\n    shiftLU(self, hit)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, lu, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.lu = lu\n  this.length = length\n  this.now = now\n  if (maxAge) this.maxAge = maxAge\n}\n\n})()\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { withStyles } from '@material-ui/core/styles';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport Layout from '../components/Layout'\nimport { Typography, ButtonBase, DialogTitle } from '@material-ui/core';\nimport Card from '@material-ui/core/Card';\nimport CardActionArea from '@material-ui/core/CardActionArea';\nimport CardActions from '@material-ui/core/CardActions';\nimport CardContent from '@material-ui/core/CardContent';\nimport CardMedia from '@material-ui/core/CardMedia';\nimport Button from '@material-ui/core/Button';\n\nimport axios from 'axios'\n\nimport Recorder from 'recorder-js';\nimport { recording } from '../scripts/record-script';\nimport { saveAs } from 'file-saver';\n\nconst group = {\n    height: \"30vh\",\n    textAlign: \"center\"\n}\n\nconst buttonGroup = {\n    height: \"10vh\",\n    textAlign: \"center\"\n}\n\nconst buttonStyle = {\n    marginLeft: \"20px\",\n    marginRight: \"20px\",\n}\n\nconst submitButton = {\n    marginLeft: \"20px\",\n    marginRight: \"20px\",\n    width: \"50vw\"\n}\n\n// audio stuff\nlet isRecording = false;\nlet blob = null;\nlet stream, audioContext, audioCtx, mediaRecorder, audioURL;\nlet chunks = [];\n\n\nclass record extends Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            appIsMounted: false,\n            recording: false,\n            completedRecording: false,\n        };\n    }\n\n    componentDidMount() {\n        requestAnimationFrame(() => {\n            this.setState({ appIsMounted: true });\n            const resampler = require('audio-resampler');\n        });\n\n        const constraints = {audio: true};\n        const cons = { audio: { sampleRate: 44100, channelCount: 2, sampleSize: 16 } }\n        navigator.mediaDevices.getUserMedia(cons).then(stream => {\n            mediaRecorder = new MediaRecorder(stream)\n\n        })\n    }\n\n    recordStart = () => {\n        // initialize the audio recorder stuff\n        blob = null;\n        audioURL = null;\n        this.setState({recording:true});\n        audioContext =  new (window.AudioContext || window.webkitAudioContext)();\n        console.log(audioContext)\n        mediaRecorder.start();\n    }\n\n    recordStop = () => {\n        mediaRecorder.stop();\n\n        this.setState({completedRecording: true})\n        this.setState({recording:false});\n\n        console.log('recorder on stop', mediaRecorder)\n        console.log('audio context on stop', audioContext)\n\n        mediaRecorder.ondataavailable = function(e) {\n            chunks.push(e.data);\n            blob = new Blob(chunks);\n            console.log(blob)\n            audioURL = window.URL.createObjectURL(blob);\n            const resample = resampler(audioURL, 44100)\n        }\n    }\n\n    recordPlay = () => {\n        const a = new Audio(audioURL);\n        a.play();\n    }\n\n    submitRecording = () => {\n        alert('sending the recording to the server')\n        const data = new FormData()\n        data.append('sample', this.state.selectedFile)\n\n        //send data to endpoint via axios\n        axios.post(\"http://localhost:8080/voicecompare\", data)\n            .then(res => {\n                console.log(res.statusText);\n                console.log(res);\n            }).then(() => {\n                document.location.href = \"/results\"\n            })\n\n        saveAs(audioURL, \"recoding.wav\");\n    }\n\n    render() {\n        if (this.state.appIsMounted) {\n            return (\n                <div>\n                    <Layout>\n                        <Paper elevation={\"1\"}>\n                            <Grid container spacing={24}>\n                                {/* title and subtitle */}\n                                <Grid item xs={12} style={group}>\n                                    <Typography variant=\"h1\" component=\"h3\">\n                                        Record\n                                    </Typography>\n                                    <Typography variant=\"h5\">\n                                        Click the record button and record an attempt to match your selected speech sample.\n                                    </Typography>\n                                </Grid>\n                                {/* start/stop buttons */}\n                                <Grid style={buttonGroup} container xs={12} direction=\"row\" justifyContent=\"center\" alignItems=\"center\" justify=\"center\" alignContent=\"space-between\">\n                                    <Button\n                                        style={buttonStyle}\n                                        variant='contained'\n                                        color='primary'\n                                        onClick={this.recordStart}>\n                                    Record Sample </Button>\n                                    <Button\n                                        style={buttonStyle}\n                                        variant='contained'\n                                        color='secondary'\n                                        onClick={this.recordStop}\n                                        disabled={!this.state.recording}>\n                                    Stop Recording </Button>\n                                    <Button\n                                        style={buttonStyle}\n                                        variant='contained'\n                                        color='default'\n                                        onClick={this.recordPlay}\n                                        disabled={!this.state.completedRecording}> \n                                    Play Recording </Button>\n                                </Grid>\n                                <Grid style={buttonGroup} container xs={12} direction=\"row\" justifyContent=\"center\" alignItems=\"center\" justify=\"center\">\n                                    <div>\n                                        <Button\n                                            style={submitButton}\n                                            variant='contained'\n                                            color='primary'\n                                            onClick={this.submitRecording}\n                                            disabled={!this.state.completedRecording}> \n                                        Submit Recording </Button>\n                                    </div>\n                                </Grid>\n                            </Grid>\n                        </Paper>\n                    </Layout>\n                </div>\n            );\n        } else {\n            return false;\n        }\n    }\n}\n\nexport default record"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;AAEA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAwBA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAhCA;AAkCA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;AACA;AACA;AACA;AAvDA;AAyDA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtEA;AACA;AACA;AACA;AAHA;AAFA;AAOA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;;;AAoDA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AACA;AACA;AACA;;;;AArIA;AACA;AAuIA;;;;;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}